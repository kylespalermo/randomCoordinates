//class to hold coordinates pulled out of CSV file
class Coord {
  constructor(name, xPos, yPos) {
    this.xPos = xPos;
    this.yPos = yPos;
    this.name = name;
  }
}

//class to hold new coordinate sets generated by "random" button
class RandomCoordSet {
  constructor(nameRand, xPosRand, yPosRand) {
    this.xPosRand = xPosRand;
    this.yPosRand = yPosRand;
    this.nameRand = nameRand;
  }
}

//holds the "row" in the coords array where a composition begins, e.g. 2nd composition starts on row 20.
let arrayNumber;

//for moving from array number through each of the ten subsequent "rows", e.g. 20, 21, 22, 23 . . . 29
let arrayRow;

//how many steps do you want to use to draw each line? 
let incr = 100;

//counts how far along the composition is as it completes the number of draws specificed by "incr" variable
let drawCount = 0;

//stores the vector of single line defined by the difference between the nth and n+1th coordinate
//for the x (xMove) and y (yMove) values and the coordinates of those lines as they build up by the "incr" value
let xMove;
let yMove;


//stores the initial value of xMove and yMove, the vector from n to n+1 coordinates divided by the increment value
let xIncr;
let yIncr;

//holds .csv data
let table;

//array of coordinates for lines
let coords = [];

//stores value of (canvas width - margin)/100, i.e. divides canvas as a set of 100 grid cells
let widthVar;

//the width of canvas - margins, I give the canvas some margins to (a) avoid ugly clipping of line corner joins
//and (b) to allow our grid lines to creep out of the grid a little bit for nice visual effect
let drawArea;

//stores number of rows in .csv table
let length;

//array to store random coordinates values generated by "random" button
let randomArray = [];

function preload() {
  table = loadTable("coordsData_rev(10s).csv", "csv", "header");
}

//populate coords array with Coord values matching up with table rows
function loadData() {
  const coordsData = table.getRows();
  length = table.getRowCount();

  for (let i = 0; i < length; i++) {
    let name = coordsData[i].getNum("array#");
    let xPos = coordsData[i].getNum("x");
    let yPos = coordsData[i].getNum("y");
    coords[i] = new Coord(name, xPos, yPos);
  }
}

function createWindow() {

  getWrapperWidth();//passed from main script file, gets width of wrapper div for canvas
  createCanvas(wrapperWide, wrapperWide);

  //margins here are 40px
  widthVar = (width - 40) / 100;
  drawArea = (width - 40);
}

//if user resizes window: redraw canvas, reset size-dependent variables
//and run the switchbox function to restart the composition
function windowResized() {

  getWrapperWidth();
  resizeCanvas(wrapperWide, wrapperWide);

  widthVar = (width - 40) / 100;
  drawArea = (width - 40);

  switchBox();
}

//this gives us an array with a new set of coordinates generated by the "random" button
//i.e., not drawn from the pre-loaded csv
function randomArrayMaker() {

  let count = 0; //helper number counts up

  let nameRand = btnValue;

  let xPosRand = int(random(0, 100)); //random x coordinate to start
  let yPosRand = int(random(0, 100)); //random y coordinate to start
  let xMoveRand = int(random(0, 5)); //random distance from first x to second x value
  let yMoveRand = int(random(0, 5)); //same for y

  let xDirRand = 1; //initial movement direction is positive for x and y
  let yDirRand = 1;

  randomArray[count] = new RandomCoordSet(nameRand, xPosRand, yPosRand); //save first "random" coordinate

  while (count < 10) { //create nine more coordinates

    if ((xMoveRand == 0) && (yMoveRand == 0)) {//if the dot gets stuck, draw again
      xMoveRand = int(random(0, 5));
      yMoveRand = int(random(0, 5));
    }

    //create a new x coordinate that is xDirRand from the initial coordinate
    for (let i = 0; i < xMoveRand; i++) {
      xPosRand += xDirRand;
      
      //and when you hit a wall as you move horizontally, decide a new distance variable for both x and y
      //and change the direction of x to its opposite, increment "count", and save the location of the wall hit
      //as the nth coordinate and break
      if ((xPosRand <= 0) || (xPosRand >= 100)) { 
        xMoveRand = int(random(0, 5));
        yMoveRand = int(random(0, 5));
        xDirRand *= -1;
        count++;
        randomArray[count] = new RandomCoordSet(nameRand, xPosRand, yPosRand);
        break;
      }
    }

    //same process as above for the y direction
    for (let i = 0; i < yMoveRand; i++) {
      yPosRand += yDirRand;
      if ((yPosRand <= 0) || (yPosRand >= 100)) {
        xMoveRand = int(random(0, 5));
        yMoveRand = int(random(0, 5));
        yDirRand *= -1;
        count++;
        randomArray[count] = new RandomCoordSet(nameRand, xPosRand, yPosRand);
        break;
      }
    }
  }//end while loop
  
  //create modal popup showing the "random" coordinates array
  newRandModal();
}


function setup() {
  loadData();
  createWindow();
  colorMode(RGB, 255, 255, 255);
  rectMode(CORNER);
}

//switch & case scheme for responding to each button based on its input value
function switchBox() {
  switch (btnValue) {
    case (btnValue):
      if (btnValue == 100) { //the "random" button has 100 as its value, so if clicked, run that function
        randomArrayMaker();
        for (let i = 0; i < 10; i++) { //save the random array coordinates as the 100th set in coords array
          xPos = randomArray[i].xPosRand;
          yPos = randomArray[i].yPosRand;
          name = randomArray[i].nameRand;
          coords[i + 1000] = new Coord(name, xPos, yPos);
          }
        arrayNumber = btnValue * 10; //start composition from 1000th item in array
        arrayRow = btnValue * 10;
        }
        else if (btnValue != 0) { //if button value is anything else except "0", run program from corresponding .csv data
          arrayNumber = btnValue * 10; //with first row as 10x coordinate-set number, e.g. drawing 10 starts on row 100.
          arrayRow = btnValue * 10 // because each composition is composed of 10 coordinates
          } else {
          arrayNumber = btnValue; //else, btnValue is "0", at which point you start at csv row 0 (not counting header)
          arrayRow = btnValue;
          }

      drawCount = 0; //reset draw count when new button is clicked
      
      //and draw over the old stuff with a squeaky clean white rectangle
      fill(255);
      noStroke(); 
      rect(0, 0, width, height);

      //reset stroke weight
      strokeWeight(1);

      //create vertical gridlines
      push();
      translate(0, 20);
      stroke(255, 180, 217);
      line(0, 0, width, 0);
      for (let i = 1; i <= 100; i++) {
        if (i % 10 == 0) {
          stroke(255, 180, 217)
          } else {
          stroke(255, 180, 217, 50);
          }
        line(0, (drawArea / 100) * i, width, (drawArea / 100) * i);
        }
      pop();

      //create horizontal gridlines
      push();
      translate(20, 0);
      stroke(255, 180, 217);
      line(0, 0, 0, height);
      for (let i = 1; i <= 100; i++) {
        if (i % 10 == 0) {
          stroke(255, 180, 217)
        } else {
          stroke(255, 180, 217, 50)
        }
        line((drawArea / 100) * i, 0, (drawArea / 100) * i, height);
      }
      pop();
      break;
  }
}


function draw() {

  if (btnValue != null) { //if a button is clicked, run switchBox then reset value to "null"
    switchBox();
    btnValue = null;
  }

  // drawing lines occurs using draw loop, not baked into another loop. Drawcount increments at bottom of draw.
  //this divides each line by an increment value set globally above and builds it incrementally during each loop. 
  //thus long lines get drawn fast, short lines get drawn slow. could implement some fix for that in future.
  if ((drawCount == 0) && (arrayRow < arrayNumber + 9)) {
    xMove = ((coords[arrayRow + 1].xPos * widthVar) - (coords[arrayRow].xPos * widthVar)) / incr;
    yMove = ((coords[arrayRow + 1].yPos * widthVar) - (coords[arrayRow].yPos * widthVar)) / incr;
    xIncr = xMove;
    yIncr = yMove;
  }

  //if arrayRow is less than the last coordinate number of the corresponding composition
  //incrementally draw corresponding line
  if (arrayRow < arrayNumber + 9) {
    strokeWeight(5);
    strokeCap(ROUND);
    stroke(255, 0, 100);
    push();
    translate(20, 20);
    beginShape();
    vertex(coords[arrayRow].xPos * widthVar, coords[arrayRow].yPos * widthVar);
    vertex((coords[arrayRow].xPos * widthVar) + xMove, (coords[arrayRow].yPos * widthVar) + yMove);
    endShape();
    pop();
  }

  xMove += xIncr;
  yMove += yIncr;
  drawCount++;

  if (drawCount == incr) {
    arrayRow++;
    drawCount = 0;
  }
}